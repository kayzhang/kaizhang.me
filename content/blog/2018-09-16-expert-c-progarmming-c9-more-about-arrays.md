---
title: 《Expert C Programming》 第 9 章：再论数组
subtitle: 全文摘录及小部分修改与备注
date: '2018-09-16'
slug: expert-c-progarmming-c4-more-about-arrays
categories:
  - C
  - Expert C Programming
  - Arrays
  - Pointers
tags:
  - arrays
  - pointers
toc: true
---

# 第 9 章 再论数组

## 9.1 什么时候数组与指针相同
第 4 章着重强调了数组和指针并不一致的绝大多数情形。本章的开始部分就是讲述可以把它们看做是相同的情形。在实际应用中，数组和指针可以互换的情形要比两者不可互换的情形更为常见。让我们分别考虑“声明”和“使用”（使用它们传统的含义）这两种情况。

声明本身还可以分成 3 种情况：

* 外部数组（external array）的声明；
* 数组的定义（记住，定义是声明的一种特殊情况，它分配内存空间，并可能提供一个初始值）；
* 函数参数的声明。

（1）所有作为函数参数的数组名总是可以通过编译器转换为指针（**此时在形参中无论是声明为数组还是指针，最终得到的都是指针**）。  
（2）在其他所有情况下（最有趣的情况就是“在一个文件中定义为数组，在另一个文件中声明为指针”，第 4 章已有所描述），数组的声明得到的是一个数组，指针的声明得到的是一个指针，因此定义与声明要保持一致，两者不能混淆。  
（3）但在使用数组（在语句或表达式中引用）时，数组总是可以写成指针的**形式**，两者可以互换。下图对这些情形作了总结。

![是么时候数组和指针相同](https://i.gyazo.com/810a2a15ba8d11d9197a4be96e2d4477.png)
<center>什么时候数组和指针相同</center>

**然而，数组和指针在编译器处理时是不同的，在运行时的表示形式也是不一样的，并可能产生不同的代码。（参见 [《Expert C Programming》 第 4 章：数组和指针](https://kaizhang.me/note/2018/09/expert-c-progarmming-c4-arrays-and-pointers/)）  
对编译器而言，一个数组就是一个地址，一个指针就是一个地址的地址**，你应该根据情况做出选择。

## 9.2 为什么会发生混淆
为什么人们会错误地认为数组和指针是可以完全互换的呢？这是因为他们阅读了标准的参考文献！

*The C Programming Language*，第二版：

> As formal parameters in a function definition
> 
> char s[];  
> and  
> char *s;
> 
> are equivalent; ...

人们在阅读后一句话时，很容易忘掉前面还有一句“作为函数定义的形式参数时”，尤其是整句话的重点在于“数组下标表达式总是可以改写成带偏移量的指针表达式”。

在作为函数的参数时，数组和指针是完全可以互换的，如下所示：

```C
char my_array[10];
char *my_ptr;
...
i = strlen(my_array);
j = strlen(my_ptr);
```

还有许多类似下面的语句：

```C
printf("%s %s", my_ptr, my_array);
```

它清楚地展示了数组和指针的可互换性。人们很容易忽视这只是发生在一种特定的上下文环境中，也就是它们作为一个函数调用的参数使用。更遭的是，你可以如下编写：

```C
char a[10];
...
printf("array at location %x holds string %s", a, a);
```

在同一条语句中，既把数组名作为一个地址（指针），又把它作为一个字符数组。这条语句之所以可行是因为 `printf` 是一个函数，所以数组实际上是作为指针来传递的。我们也习惯了在 `main` 函数的参数中看到 `char **argv` 或 `char *argv[]` 这样的形式，它们也是可以互换的。同样，这个之所以成立是因为 `agrv` 是一个函数的参数，但它仍然诱使程序员错误地总结出“C 语言在地址运算方法上是一致和规则的”。若在脑子里已经存在这样一个概念，再加上平时常常可以见到数组下标表达式被写成指针的形式，久而久之，便很容易把数组和指针混淆。

下边这个表格非常重要！！！

> **软件信条**
> 
> 什么时候数组和指针是相同的：
> 
> **规则 1.** **表达式**中的数组名（用于区别声明中的数组名）被编译器当作一个指向该数组第一个元素的指针（具体释义见 ANSI C 标准第 6.2.2.1 节）。（例外情况在下面讨论）
> 
> **规则 2.** 数组的下标引用总是与指针的偏移量引用相同（具体释义见 ANSI C 标准第 6.3.2.1 节）。
> 
> **规则 3.** 在函数参数的声明中，数组名被编译器当作指向该数组第一个元素的指针（具体释义见 ANSI C 标准第 6.7.1 节）。

注：规则 1 存在几个极为少见的例外，即需要将数组作为一个整体来考虑的情况。在下列情况下，对数组的引用不能用指向该数组第一个元素的指针来代替：

> * 数组作为 `sizeof` 的操作数 -- 显然此时需要的是整个数组的大小，而不是指针所指向的第一个元素的大小；  
> 注：此处讨论的是数组是否被转换成指针，因此作为函数参数的数组不在此讨论范围内，因为其本身就是一个指针，何来转换成指针？因此通过 `sizeof` 操作实参指针时，获取的是指针变量的长度，而非数组元素的个数。
* 使用 `&` 操作符取数组的地址；
* 数组是一个另一个数组的字符串（或宽字符串）常量（string literal）初始值。  
如：`char str[] = "abc";`，其中 string literal `"abc"`的类型为 not modifiable specified character array type，但是并未转换为指向第一个元素的指针，而是作为一个数组整体用于初始化数组 `str`。

具体的 C 参考文档中是这么描述规则 1 的：

> Array to pointer conversion
> 
> Any lvalue expression of array type, when used in any context other than
> 
> * as the operand of the address-of operator
* as the operand of sizeof
* as the string literal used for array initialization
* as the operand of _Alignof
(since C11)
> 
> undergoes an implicit conversion to the pointer to its first element. The result is not an lvalue.

### 9.2.1 规则 1：“表达式中的数组名”就是指针
上面的规则 1 和规则 2 合在一起理解，就是对数组下标的引用总是可以写成“一个指向数组的起始地址的指针加上偏移量”。例如，假如我们声明：

```C
int a[10], *p, i = 2;
```

就可以通过以下任何一种方式来访问 `a[i]`：

```C
// 方式一
p = a;
p[i];

// 方式二
p = a;
*(p + i);

// 方式三
p = a + i;
*p
```

事实上，可以采用的方法更多。**对数组的引用如 `a[i]` 在编译时总是被编译器首先改写成 `*(a + i)` 的形式。**  
C 语言标准要求编译器必须具备这个概念性的行为。也许遵循这个规则的捷径就是记住方括号 `[]` 表示一个取下标操作符，就像加号表示一个加法运算符一样。取下标操作符取一个整数和一个指向类型 T 的指针，所产生的结果类型是 T，一个在表达式中的数组名于是就成了指针。你只要记住：在表达式中，指针和数组是可以互换的，因为它们在编译器里的最终形式都是指针，并且都可以进行取下标操作。就像加法一样，取下标操作符的操作数是可以互换的（它并不在意操作数的先后顺序，就像在加法中 3 + 5 和 5 + 3 并没有区别）。这就是为什么在一个 `a[10]` 的声明下面两种形式都是正确的：

    a[6] = ...;
    6[a] = ...;

但在实际的代码中，上面第二种形式从来不曾使用，其除了可以把新手搞晕之外，实在没有什么实际意义。

编译器自动把下标值的步长调整到数组元素的大小。对起始地址执行加法操作之前，编译器会负责计算每次增加的步长。这就是为什么指针总是有类型限制，每个指针只能指向一种类型的原因所在——因为编译器需要知道对指针进行 dereference 操作时应该取几个字节，以及每个下标的步长应取几个字节。

#### 关于规则 1 中的特殊情况 `&array` 的备注
对于 `int array[10]` 这样一个数组而言，数组名 `array` 表示整个数组，其类型为 `int [10]`，在大多数表达式中被退化为指向其第一个元素的指针。注意，这里边有一个关键的概念，就是指针的类型与指针的内容（指针存储的地址内容，而非指针存储的地址对应内存中的内容），此处虽然指针的具体内容为第一个元素的最低字节的地址（第一个元素为 `int` 包含4个字节），但是其类型为 `int *`，我们说其指向的为第一个元素的整体（即 4 个字节），因此这个指针的步长就是 4 个字节（1 个 `int` 的长度），`array[1]` 指向数组的第二个元素。

然后我们看 `&array` 这一个表达式，这是规则 1 的例外情况，此时 `array` 并未退化为指针，而是整个数组，因此 `&array` 的类型为 `int (*)[size]`，虽然这个指针与指向数组第一个元素的指针的具体内容都是第一个元素最低字节的地址，但是我们并不能说 `&array` 指向数组的第一个元素，而应该说其指向这整个数组，它的步长也不再是一个元素对应的 4 字节，而是整个数组对应的 4 * 10 = 40 个字节。因此，`(&array)[1]` 取的是内存中紧挨着这个数组后边的 40 个字节中的内容，而 `arrar[1]` 取的是数组内部 4 个字节的内容。

```c
int arr[10];
printf("%lu, %lu, %lu, %lu\n", sizeof arr, sizeof &arr, sizeof arr[0], sizeof (&arr)[0]);
```

输出为：

    40, 8, 4, 40

因此，此处就引出了 2 种获取数组长度的方法，具体可参见：[数组和指针三大规则解析](https://kaizhang.me/note/2018/09/rules-about-arrays-and-pointers/)

```C
int arr[10];

// 方法一：
size_t size1 = (sizeof arr) / (sizeof arr[0]);

// 方法二
size_t size2 = (&arr)[1] - arr;
```

### 9.2.2 规则 2：C 语言把数组下标作为指针的偏移量
把数组下标作为指针加偏移量是 C 语言从 BCPL（C 语言的祖先）继承过来的技巧。这个规则导致在运行时增加对 C 语言下标范围的检查是非常不切实际的。因为取下标操作符并不能保证正在被访问的一定是数组。而且，程序员完全可以使用指针来访问数组，从而绕过下标操作符。在这种情况下，数组下标范围检测并不能检测所有对数组访问的情况。事实上，下标范围检测被认为是并不值得加入到 C 语言中的特性。

### 9.2.3 规则 3：“作为函数参数的数组名”等同于指针
规则 3 也需要进行解释。首先，让我们回顾一下 *The C Programming Language* 中所提到的一些术语。

| 术语 | 定义 | 例子 |
| :--: | :--: | :--: |
| 形参（parameter） | 它是一个变量，在函数定义或函数声明的原型中定义。又称“形式参数（formal parameter）” | int power(int base, int n); //其中 base 和 n 都是形参 |
| 实参（argument）| 在实际调用一个函数时所传递给函数的值。又称“实际参数（actual parameter）” | i = power(10, j); // 10 和 j 都是实参。在同一个函数的多次调用时，实参可以不同 |

标准规定作为“类型的数组”的形参的声明应该调整为“类型的指针”。在函数形参定义这个特殊情况下，编译器必须把数组形式改写成指向数组第一个元素的指针形式。编译器只向函数传递数组的地址，而不是整个数组的拷贝。不过，现在让我们重点观察一下数组，隐性转换意味着三种形式是完全等同的。因此，在 `my_function()` 的调用中，无论实参是数组还是真的指针都是合法的。

```C
my_function(int *turnip) { ... }
my_function(int turn[]) { ... }
my_function(int turnip[200]) { ... }
``` 

## 9.3 为什么 C 语言把数组形参当作指针
把作为形参的数组和指针等同起来是出于效率原因的考虑。在 C 语言中，所有非数组形式的数据实参均以**传值形式（对实参作一份拷贝并传递给调用的函数，函数不能修改作为实参的实际变量的值，而只能修改传递给它的那份拷贝）**调用。

然而，如果要拷贝整个数组，无论在时间上还是在内存空间上的开销都可能是非常大的。而且在绝大部分情况下，你其实并不需要整个数组的拷贝，你只想告诉函数在那一时刻对哪个特定的数组感兴趣。要达到这个目的，可以考虑的方法是在形参上增加一个存储说明符（storage specifier），表示它是**传值调用**还是**传址调用**，Pascal 语言就是这样做的。如果采用“所有的数组在作为参数传递时都转换为指向数组起始地址的指针，而其他的参数均采用传值调用”的约定，就可以简化编译器。**类似地，函数的返回值决不能是一个函数数组，而只能是指向数组或函数的指针。**

有些人喜欢把它理解成除数组和函数之外的所有的 C 语言参数在缺省情况下都是传值调用，数组和函数则是传址调用。数据也可以使用传址调用，只要在它前面加上取地址操作符（`&`），这样传递给函数的是实参的地址而不是实参的拷贝（更确切的说是指针的拷贝或者实参地址的拷贝）。**事实上，取地址操作符的主要用途就是实现传址调用。“传址调用”这个说法从严格意义上说并不十分准确，因为编译器的机制非常清楚——在被调用的函数中，你只拥有一个指向变量的指针而不是变量本身（即本质上传址调用还是传值调用，因为被传递的实参为变量的地址，函数接收到的也是变量的地址，变量本身是没有被传递给被调用函数的，只不过在被调用函数内部我们可以通过形参，即指向变量的指针来对变量本身操作罢了。）**如果你取实参的大小或对它进行拷贝，就能体会到两者的差别。

不管程序员实际把形参声明为数组（程序员打算传递给函数的东西）或者指针（函数实际所接收到的东西），**在函数内部**，编译器始终把它当做一个指向一个**长度未知的数组**第一个元素的指针。这样，编译器可以产生正确的代码，而不需要对数组和指针这两种情况作仔细区分。

因此，不管程序员实际所写的是哪种形式，函数并不自动知道指针所指的数组共有多少个元素，所以必须有个约定，如数组以 NUL 结尾或者另有一个附加的参数表示数组的范围。当然，并不是每种语言都是这样做的，比如 Ada，它的每个数组都有一些附加信息，表示每个元素的长度、数组的维数以及下标范围。

在下列定义中

```C
func(int *turnip) { ... }
// 或
func(int turnip[]) { ... }
// 或
func(int turnip[200]) { ... }

int my_int; /* 数据定义 */
int *my_int_ptr;
int my_int_array[10];
```

你可以合法地使用下列任何一种实参来调用上面任何一个原型的函数。它们常常用于不同的目的：

<center>数组/指针实参的一般用法</center>

| 调用时的实参 | 类型 | 通常目的 |
| :--: | :--: | :--: |
| func(&my_int); | 一个整型数的地址 | 一个 int 参数的传址调用 |
| func(my_int_ptr); | 指向整型数的指针 | 传递一个指针 |
| func(my_int_array); | 整型数组 | 传递一个数组 |
| func(&my_int_array[i]); | 一个整型数组某个元素的地址 | 传递数组的一部分 |

相反，如果处于 `func()` 函数内部，就没有一种容易的方法分辨这些不同的实参，因此也无法知道调用该函数是出于何种目的。所有属于函数实参的数组在编译时都会被编译器改写成指针。因此，在函数内部对数组参数的任何引用都将产生一个对指针的引用。

因此，很有意思的是，没有办法把数组本身传递给一个函数，因为它总是被自动转换为指向数组的指针。当然，在函数内部使用指针，所能进行的对数组的操作几乎跟传递原原本本的数组没有差别。只不过，如果想用 `sizeof (实参)` 来获得数组的长度，所得到的结果不正确而已。

## 9.4 数组片段的下标

## 9.5 数组和指针可交换性总结
1. 用 `a[i]` 这样的形式对数组进行访问总是被编译器“改写”或解释为像 `*(a + 1)` 这样的指针访问。
2. 指针始终就是指针。它绝不可以改写成数组。你可以用下标形式访问指针，一般都是指针作为函数参数时，而且你知道实际传递给函数的是一个数组。
3. 在特定的上下文中，也就是它作为函数的参数（也只有这种情况），一个数组的声明可以看作是一个指针。作为函数参数的数组（就是在一个函数调用中）始终会被编译器修改称为指向数组第一个元素的指针。
4. 因此，当把一个数组定义为函数的参数时，可以选择把它定义为数组，也可以定义为指针。不管选择哪种方法，在函数内部事实上获得的都是一个指针。
5. 在其他所有情况中，定义和声明必须匹配。如果定义了一个数组，在其他文件对它进行声明时也必须把它声明为数组，指针也是如此。

## 9.6 C 语言的多维数组
