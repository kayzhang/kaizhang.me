---
title: 指针的类型 Casting
subtitle: ECE 551 的一个作业题
date: '2018-09-14'
slug: pointer-type-casting
categories:
  - C
  - Type Casting
  - Arrays
  - Pointers
tags:
  - casting
  - pointers
---
Question:

> Suppose we have a platform with 64-bit doubles and 32-bit ints.
> 
> We write the following (horrible) code:
> 
```c
double d = 3.14159;
int * p = (int*) &d;
*p = 42;
printf("%f\n", d);
```
> 
> What would you expect the behavior to be?
> 
> A.  It would print 42.0.  
> B.  It would crash on the second line (`int * p = (int*) &d;`)  
> C.  It would crash on the third line (`*p = 42;`)  
> D.  It would print something near 3.14159, but with some of the least significant digits altered.  
> E.  None of the above

Solution:

3.14159 对应的二进制为：

    11.00100100001111110011111000000011011100001100110111

写成科学计数法为：

    1.100100100001111110011111000000011011100001100110111 * 2^1

因此在内存中的表示为：

1. 第1位为符号位：0
2. 紧接着11位为指数位：1 + 1023（其中 1023 为 bias，32 位 float 单精度浮点数的 bias 是127，64位 double 双精度浮点数的 bias 是1023），所以指数是 1024，对应的二进制为：`10000000000`
3. 最后是 52 位的 mantissa 即尾数（此处应 omit 掉科学计数法中的整数部分 1，只考虑小数部分），对应的二进制为：`1001001000011111100111110000000110111000011001101110`

所以 3.14159 在内存中是：

    0    100 | 00000000    1001 | 00100001 | 11111001 | 11110000 | 00011011 | 10000110 | 01101110  

double 一共 8 个字节：下边假设 double d 在内存中的地址为 100 --> 107

```
107 --> 01000000  
106 --> 00001001  
105 --> 00100001  
104 --> 11111001  
103 --> 11110000  
102 --> 00011011  
101 --> 10000110  
100 --> 01101110  
```

所以 `&d` 的值就是 d 的地址，也就是 8 个字节中最低那个字节的地址 100，即 `&d == 100`

然后 `int *p = (int*) &d;` 是把 `&d` 进行 **casting** 赋值给一个 `int*` 的 pointer p，（不 cast 的话会报错，因为不能把 `double*` 类型的 pointer 赋值给 `int*` 类型的pointer），此时，`p == &d == 100`。

下边一步是 `*p = 42;`，由于 p 是 `int*` 类型，所以 `*p` 会从其内部存储的地址（即 100）开始向上查找 4 个字节（并非 8 个字节），并将其赋值为 42，即 `00000000 | 00000000 | 00000000 | 00101010`

所以，内存中数据变为

```
107 --> 01000000  不变  
106 --> 00001001  不变  
105 --> 00100001  不变  
104 --> 11111001  不变  
103 --> 11110000  变为 00000000  
102 --> 00011011  变为 00000000  
101 --> 10000110  变为 00000000  
100 --> 01101110  变为 00101010
```

然后是 `printf(%f\n", d);` 由于 d 的类型从始至终没发生变化，d 还是 double，所以 d 的值就是上边 8 个字节对应的值（即第 1 位为符号位，没变化；接着 11 位为指数位，没变化；最后 52 位是去掉了二进制科学计数法的整数部分 1 之后的小数部分，发生了变化）。

这个新数为：

    1.10010010000111111001    00000000 | 00000000 | 00000000 | 00101010 * 2^1

十进制为：

    3.14158821105958896425

由于这个数（d，double 类型）完全可以由 float 类型表示，因此 `%f` 输出时并未损失精度，并且 `%f` 默认输出6位小数，因此最终输出为：

    3.141588

如果用 `%.25f` 或者 `%.25lf` 参数输出 d，结果一致均为：

    3.14158821105958896425
 